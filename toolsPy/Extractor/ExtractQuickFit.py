#!/usr/bin/env python3



import sys
import argparse
from argparse import RawTextHelpFormatter
import numpy as np
import matplotlib.pyplot as plt
import QuickFit as QuickFit





__author__ = "Jonathan Lahnsteiner"
__copyright__ = ""                            
__license__ = "GPL"
__version__ = "1.0.0" 
__maintainer__ = "Jonathan Lahnsteiner"
__email__ = "jonathan.lahnsteiner@gmx.at"
__status__ = "Production"




def getOptions( args = sys.argv[1:] ):
    """     
    parse user input when the file is executed as main file
    """                                                                                         
    parser = argparse.ArgumentParser(description="Parses command. All input"
            + "files are expected to come from the DSLEAP code" , formatter_class = RawTextHelpFormatter )

    parser.add_argument( "-m" , "--Mode", help = "Input the fitting mode you want to use\n" 
                                               + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
                                               + "Mode 1 -> Fit all Signals (default), or supply \n"
                         + "al -> Mode 1 ; fit all signals in file\n"
                         + "ms -> Mode 2 ; Manually select signals of file for which fitting procedure worked\n"
                         + "as -> Mode 3 ; Automatic selection of Signals for which fitting worked."
                         + " Default r^2 threshold is 0.85" , default = "al" )

    parser.add_argument( "-fs" , "--SignalFile",                                                 
             help = "Supply filename of the file you want to fit" )

    parser.add_argument( "-fq" , "--qpath",                                                     
             help = "Supply the name of the Qpath file you want to use" )

    parser.add_argument( "-tr" , "--treshold",                                                     
             help = "You can supply a threshold r^2 as a minium fitting accuracy.\n"
                +   "The default value is set to 0.85" , type = float , default = 0.85 ) 

    options = parser.parse_args( args )                                                         
    return options                                                                              
                                                                                                





def CheckInput( a , b ):
    """
    Check user input where a an input of 0 or 1 is expected
    """
    x = "100000000000000000000000000000"
    while x != a and x != b:
        x  = input("Please input a number 0 or 1 : ")
        if x == a:
           return  int( x )
        elif x == b:
           return int( x )
        else:
           print( "Try again" )



class MakeBand:
    def __init__( self , fname , Qpath ):
        """
        supply a filename -> fname 
        containing a Signal generated by the DSLEAP code
        and a file Qpath generated by the DSLEAP code
        """
        self.fname  =  fname
        self.QPath = np.loadtxt( Qpath )




    def FitAllSignals( self ):
        """
        fit Lorentz distribution to all signals
        in the supplied file
        generate a data array self.Parameters
        containing along the first dimension the qpath
        along the second dimension the fit parameters can be found
       
        self.FitParameters format 
        q1   freq1    FWHM1
        q2   freq2    FWHM2
        q3   freq3    FWHM3 
        .      .        .
        .      .        .
        .      .        .
        .      .        .
        """
        self.Parameters  = np.zeros( [ self.QPath.shape[0] , 3 ] )
        col = 0
        for i in range( self.QPath.shape[0] ):
            x = QuickFit.MakeQuickFit( self.fname , i )
            params , pcov  =  x.LorentzOnly()
            self.Parameters[ col , 0 ]   =  self.QPath[ i-1 ]
            self.Parameters[ col , 1: ]  =  params
            print( self.Parameters[ col , : ] )
            col += 1



    def ManualSelecterYesNo( self ):
        """
        fit Lorentz distribution to all signals
        in the supplied file
        generate a data array self.Parameters
        containing along the first dimension the qpath
        along the second dimension the fit parameters can be found

        after a single signal was fitted the user is asked 
        if the signal should be used and written to
        the file or if the fitting procedure was
        not converging and the data should be ignored
        Only useful fit parameters will be written to the output file
       
        self.FitParameters format 
        q1   freq1    FWHM1
        q2   freq2    FWHM2
        q3   freq3    FWHM3 
        .      .        .
        .      .        .
        .      .        .
        .      .        .
        """

        self.Parameters  =  []
        for i in range( self.QPath.shape[0] ):
            x = QuickFit.MakeQuickFit( self.fname , i+1 )
            params , pcov  =  x.LorentzOnly()
            plt.title( "Showing column " + str( i+1 ) )
            plt.plot( x.data[ : , 0 ] , x.Fits[ : , 0 ] , label = "Fit" )
            plt.plot( x.data[ : , 0 ] , x.data[ : , i+1 ] , label = "data" )
            plt.legend()
            plt.show()
            YesNo  =  CheckInput( "0" , "1" )
            if ( YesNo ):
                a = np.asarray( [ self.QPath[i] , params[0] , params[1] ] )
                self.Parameters.append( a )

        self.Parameters =  np.asarray( self.Parameters )



    def AutomaticSelecterYesNo( self , tresh = 0.8 ):
        """
        fit Lorentz distribution to all signals
        in the supplied file
        generate a data array self.Parameters
        containing along the first dimension the qpath
        along the second dimension the fit parameters can be found

        after a single signal was fitted the 
        correlation coeffcient is checked to above a 
        threshold value. If correlation coeffcient is
        above threshold the fit parameters will be used
        otherwise they are ignored
       
        self.FitParameters format 
        q1   freq1    FWHM1
        q2   freq2    FWHM2
        q3   freq3    FWHM3 
        .      .        .
        .      .        .
        .      .        .
        .      .        .
        """
        self.Parameters  =  []
        for i in range( self.QPath.shape[0] ):
            x = QuickFit.MakeQuickFit( self.fname , i+1 )
            params , pcov  =  x.LorentzOnly()
            if ( pcov > tresh ):
                a = np.asarray( [ self.QPath[i] , params[0] , params[1] , pcov ] )
                self.Parameters.append( a )

        self.Parameters =  np.asarray( self.Parameters )



    def WriteData( self ):
        """
        output is 
        """
        np.savetxt( "FitBand.dat" , self.Parameters , fmt = '%15.8f' )







if __name__=="__main__":
    options =  getOptions( sys.argv[1:] )
    x       =  MakeBand( options.SignalFile , options.qpath )
    Write   =  True

    ### select what fitting style will be used
    if ( options.Mode == "al" ):
        x.FitAllSignals()
    elif ( options.Mode == "ms" ):
        x.ManualSelecterYesNo()
    elif ( options.Mode == "as" ):
        x.AutomaticSelecterYesNo( options.treshold )
    else:
        print( "No valid mode supplied. I am going to do nothing ;-)" )
        print( "valid mode flags are\n, al -> fit all sig\n"
            +  "ms -> manually slect peaks" 
            +  "as -> automatically slect peaks" )
        Write = False

    if ( Write ):
        print( "You should find a FitBand.dat file in your folder" )
        print( "The file is structured as follows" )
        print( "Qpath  |  frequency in [time unit]^-1  |  FWHM  |  r^2" )
        x.WriteData()

